# 强缓存

##  简单总结
-  「强缓存分为两种情况，一种是发送HTTP请求，一种不需要发送。」
- 首先检查强缓存，这个阶段**不需要发送HTTP请求。**通过查找不同的字段来进行，不同的HTTP版本所以不同。
-  请求资源的的状态码为: 200 ok(from memory cache)

## 强缓存两个相关字段
「Expires」，「Cache-Control」

「强缓存分为两种情况，一种是发送HTTP请求，一种不需要发送。」
首先检查强缓存，这个阶段不需要发送HTTP请求。通过查找不同的字段来进行，不同的HTTP版本所以不同。

HTTP1.0版本，使用的是Expires，HTTP1.1使用的是Cache-Control

### Expires

Expires即过期时间，时间是相对于服务器的时间而言的，存在于服务端返回的响应头中，在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。比如下面这样:
```dotnetcli
Expires:Mon, 29 Jun 2020 11:10:23 GMT
```

表示该资源在2020年7月29日11:10:23过期，过期时就会重新向服务器发起请求。
这个方式有一个问题：「服务器的时间和浏览器的时间可能并不一致」，所以HTTP1.1提出新的字段代替它。

### Cache-Control
HTTP1.1版本中，使用的就是该字段，这个字段采用的时间是过期时长，对应的是max-age。
```dotnetcli
Cache-Control:max-age=6000
```

上面代表该资源返回后6000秒，可以直接使用缓存。
当然了，它还有其他很多关键的指令，梳理了几个重要的👇
```
cache-control常用的值（做一个简单了解即可）：
      1. no-cache: 不使用本地缓存，需要使用协商缓存。先与服务器确认返回的响应是否被更改，如果之前的响应中存在Etag，那么请求的额时候会与服务器端进行验证，如果资源为被更改则使用缓存。
      2. no-store: 直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。
      3. public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。
      4. private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。


当Expires和Cache-Control同时存在时，优先考虑Cache-Control。
当然了，当缓存资源失效了，也就是没有命中强缓存，接下来就进入协商缓存👇
```

# 协商缓存
## 简单总结
1.  向服务器发送请求，服务器会根据请求头的资源判断是否命中协商缓存
2.  如果命中，则返回304状态码通知浏览器从缓存中读取资源
3.  强缓存失效后，浏览器在请求头中携带响应的缓存Tag来向服务器发送请求，服务器根据对应的tag，来决定是否使用缓存。
4. 缓存分为两种，「Last-Modified」 和 「ETag」。两者各有优势，并不存在谁对谁有绝对的优势
   
### Last-Modified
- 这个字段表示的是「最后修改时间」。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。
- 浏览器接收到后，「如果再次请求」，会在请求头中携带If-Modified-Since字段，这个字段的值也就是服务器传来的最后修改时间。
- 服务器拿到请求头中的If-Modified-Since的字段后，其实会和这个服务器中该资源的最后修改时间对比:
- 如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。
- 否则返回304，告诉浏览器直接使用缓存。

### ETag
- ETag是服务器根据当前文件的内容，对文件生成唯一的标识，比如MD5算法，只要里面的内容有改动，这个值就会修改，服务器通过把响应头把该字段给浏览器。
- 浏览器接受到ETag值，会在下次请求的时候，将这个值作为「If-None-Match」这个字段的内容，发给服务器。
- 服务器接收到「If-None-Match」后，会跟服务器上该资源的「ETag」进行比对👇
- 如果两者一样的话，直接返回304，告诉浏览器直接使用缓存
- 如果不一样的话，说明内容更新了，返回新的资源，跟常规的HTTP请求响应的流程一样

## 既生Last-Modified何生Etag
  1. HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题
  2.  一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET
  3. 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；
  4. 某些服务器不能精确的得到文件的最后修改时间。
最后，「如果两种方式都支持的话，服务器会优先考虑ETag」

# 总结
- 首先检查Cache-Control， 尝鲜，看强缓存是否可用
- 如果可用的话，直接使用
- 否则进入协商缓存，发送HTTP请求，服务器通过请求头中的If-Modified-Since或者If-None-Match字段检查资源是否更新
- 资源更新，返回资源和200状态码。
- 否则，返回304，直接告诉浏览器直接从缓存中去资源。

![](../static/07_%E7%BC%93%E5%AD%98%E7%A4%BA%E6%84%8F%E5%9B%BE.png)


# 强缓存 & 协商缓存的共同点
    1. 都是从浏览器端读取资源
# 强缓存 VS 协商缓存的不同点
     1. 强缓存不发请求给服务器
     2. 协商缓存发请求给服务器，根据服务器返回的信息决定是否使用缓存


# 缓存位置
接下来我们考虑使用缓存的话，缓存的位置在哪里呢？
浏览器缓存的位置的话，可以分为四种,优先级从高到低排列分别👇
- Service Worker
- Memory Cache
- Disk Cache
- Push Cache


## Service Worker

是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。

这个应用场景比如PWA，它借鉴了Web Worker思路，由于它脱离了浏览器的窗体，因此无法直接访问DOM。它能完成的功能比如：离线缓存、消息推送和网络代理，其中离线缓存就是「Service Worker Cache」。



## Memory Cache
指的是内存缓存，从效率上讲它是最快的，从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了。

## Disk Cache
存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，优势在于存储容量和存储时长。

## Disk Cache VS Memory Cache

### 两者对比，主要的策略👇
- 内容使用率高的话，文件优先进入磁盘
- 比较大的JS，CSS文件会直接放入磁盘，反之放入内存。
- 
## Push Cache
推送缓存，这算是浏览器中最后一道防线吧，它是HTTP/2的内容。具体我也不是很清楚，有兴趣的可以去了解。

